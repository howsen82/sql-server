# 14 Security

This chapter covers

* Working with permissions
* Service account security
* Using `xp_cmdshell`
* Auditing privileged activity
* Attacks against encryption
* SQL injection attacks

In this chapter, we will explore some of the common mistakes that are made around the security of SQL Server. We will start by looking at the principle of least privilege. This principle states that users should only have enough permission to perform their day-to-day duties, but it is often not adhered to. We will explore the reasons for this and why it is so important. We will also explore the `sa` account, which is SQL Server’s built-in administrator account. Many accidental DBAs leave this account enabled, and we will discuss why this is not a good idea and how we can rectify it.

We will then turn our attention to service accounts. We will explore common mistakes that are made when defining our service account strategy. We will also discuss how to use a modern approach to implementing service accounts and how this can make our environment more secure and easier to manage.

We will look at the controversial subject of `xp_cmdshell`, which is an extended stored procedure that allows us (and bad actors) to interact with the operating system from inside a SQL Server instance. We will debunk the myths that lead database administrators (DBAs) to open their enterprise up to unnecessary attack.

Next, we will explore passive security, specifically, auditing. We will look at the very common mistake of not implementing auditing of administrative activity. We will also explore how to configure this in a way that avoids nonrepudiation.

Our next topic is whole-value substitution attacks. In these attacks, a bad actor will manipulate encrypted data to their advantage. We will discuss how they do this and how we can prevent it from happening.

Finally, we will explore SQL injection attacks. We will discuss how bad actors use SQL injection to attack our enterprise and how we can stop them. Ultimately, DBAs are the last line of defense against such attacks.

To get the most from this chapter, you must be familiar with some basic security terminology. Table 14.1 provides a glossary of some key security terminology that you should understand before moving on.

Table 14.1 Security terminology

| Term | Definition |
| --- | --- |
| Security principal | An entity, such as a person or an application, that is granted permission to access a resource |
| Securable | An object that can have permissions applied to it. In SQL Server, this is often an object such as a table or a stored procedure. |
| Login | A security principal at the instance level that allows a person to access an instance |
| Database user | A security principal at the database level that (usually) maps to a login and allows a person to access resources within a database* |
| Server-level role | A group that contains one or more logins and can be granted permissions on instance-level securables. If a server role is “fixed,” then it refers to a built-in role that is preconfigured with a set of permissions that meets a common use case. |
| Database level role | A group that contains one or more database users and can be granted permissions to database-level securables. If a database role is “fixed,” then it refers to a built-in role that is preconfigured with a set of permissions that meets a common use case. |
| Active directory (AD) | A Windows-hosted directory service that allows permissions to be managed centrally. |
| Domain | A collection of AD objects, such as users, groups, and computers. The information is stored within a database that is synchronized between domain controllers. Domain controllers are the servers running the domain controller service, which are used to manage AD. |
| AD user | A Windows user that is created and managed in AD. |
| AD group | A group that is created and managed in AD. It will contain AD users and can be granted permissions on securables throughout the domain. |
| Service account | A user account, typically an AD user, that is intended for running Windows services only. These accounts are typically configured to disallow interactive logins and are often set for their passwords to not automatically expire.** |
| Kerberos authentication | A secure authentication protocol used by AD that provides a method of mutual authentication via key exchange |
| Service principal name | A unique identifier for an instance of a service. This is a feature of Kerberos authentication. |
| * A contained user is not mapped to a login. Therefore, access is only possible within a single database.  ** If automatic password expiry is disabled for a service account, it should still have its password rotated. | |

## 14.1 #94 Not implementing the principle of least privilege

The bedrock of IT security strategy, the whole way through the stack, from an application down to data center security, is the *principle of least privilege*. This principle states that any security principal (such as a person or service) should only have access to the things they need to fulfill their day-to-day responsibilities. If they ever need additional privileges for a specific task, then these privileges can be granted for the duration of the task and then subsequently revoked.

Despite this being a well-understood, commonsense principle, it is often not applied at the SQL Server layer. It is scary how common it is to see a SQL Server instance with multiple members of the `sysadmin` fixed server role who are not members of the DBA team. The `sysadmin` fixed server role provides full access to a SQL Server instance—the ability to do anything.

The most common reason for this is a lack of understanding of SQL Server permissions and how to configure them. To be clear, this misunderstanding is often not with DBAs. Often the misunderstanding comes from IT professionals or organizations who do not have SQL Server as their specialist discipline. For example, it is often the case that an application team will state that they need `sysadmin` rights because they need to create and delete databases on their nonproduction server.

What is even more common is that the request comes from a third-party company that states that its software must have `sysadmin` rights on all SQL Server instances to be able to function. The most frequent offenders here are companies that provide backup tools, monitoring tools, and, ironically, sometimes even security tools.

This scenario is always particularly worrying, as complying with the request often means granting a single account `sysadmin` permission on every SQL Server instance within our enterprise. This is clearly a massive security hole. If this account is compromised, someone could gain access to all of the organization’s data.

From the DBA perspective, the mistake is to say “yes” to these requests. Admittedly, it can be hard when a vendor is categorically stating that it requires `sysadmin` permission, but as the last line of defense for an organization’s data, it is important that we remain steadfast.

For example, a backup tool that states it requires `sysadmin` permission certainly will not. It is likely that it will only require the `##MS_DatabaseManager##` server-level role and the `db_backupoperator` fixed database role in databases that need to be backed up.

> [!NOTE]
>
> The `##MS_DatabaseManager##` role was introduced in SQL Server 2022. In prior versions of SQL Server, the `db_creator` role can be used instead. The benefit of the new role is that it is consistent with Azure SQL database.

For the vast majority of use cases, there will be a fixed server role or fixed database role that grants the permissions that a user of an application requires without exposing the organization to the security risks associated with granting `sysadmin` to multiple accounts. A full list of fixed server roles can be found at <https://mng.bz/0MV6>, while a full list of fixed database roles can be found at <https://mng.bz/aVWX>.

Operational support

It is important to understand that security is not the only issue with granting non-DBAs elevated permissions. There is also the problem that, as a DBA team, we are responsible for the reliable and performant running of our SQL Server environment. If we grant elevated access outside of our team, then other people are able to make changes that we are not even aware of. This can lead to performance and stability issues that we are then on the hook to resolve ourselves.

If there is not a suitable server or database role, we can create our own custom roles with the required permissions. For example, the script in listing 14.1 creates a server role called `AvailabilityGroupsFailover`. It then adds the `SYSTEM` account to this group before adding the permissions that the `SYSTEM` account requires on the secondary replica to be able to perform a failover.

Listing 14.1 Creating a custom server role

```sql
CREATE SERVER ROLE AvailabilityGroupsFailover ;
GO

ALTER SERVER ROLE AvailabilityGroupsFailover ADD MEMBER [NT
AUTHORITY\SYSTEM] ;

GRANT ALTER ANY AVAILABILITY GROUP TO AvailabilityGroupsFailover ;

GRANT CONNECT SQL TO AvailabilityGroupsFailover ;

GRANT CREATE AVAILABILITY GROUP TO AvailabilityGroupsFailover ;

GRANT VIEW SERVER STATE TO AvailabilityGroupsFailover ;
```

The script in listing 14.2 demonstrates how to create a custom database role that fixes a common problem that DBAs see, which is the lack of a database role that allows stored procedures to be executed without granting unnecessary permissions to a database. If this script is executed in the `model` database, it will be automatically generated in all new databases that are created on the instance.

Listing 14.2 Database role to allow stored procedure execution

```sql
USE model ;
GO

CREATE ROLE ExecSP ;
GO

GRANT EXECUTE TO ExecSP ;
```

> [!TIP]
>
> The `model` database can be very useful, but we should be careful not to overload it with too many things, as this can become a burden to manage and maintain across the enterprise.

SQL Server makes it easy for us to manage permissions using the principle of least privilege. Unfortunately, other teams and organizations do not always make it quite so easy. It is important, however, that we stick to our guns and help consumers define exactly what permissions they require. This allows us to fulfill our role as the last line of defense for our organization’s data.

## 14.2 #95 Not disabling the sa account

SQL Server provides two authentication modes, namely, Windows authentication and mixed-mode authentication. If Windows authentication is configured on an instance, then all security principals must use Windows authentication to access the instance. In this scenario, we must add at least one Windows user or group to the `sysadmin` fixed server role during instance installation.

If mixed-mode authentication is configured, then the instance can be accessed either by using Windows authentication or by using second-tier authentication. *Second-tier authentication* refers to SQL logins that have a password associated with them. Users can then access the instance by specifying the name and password of the login. When mixed-mode authentication is enabled, it is still possible to add users to the `sysadmin` server role, but the `sa` account will be enabled and we must specify a password for this account during instance installation.

> [!TIP]
>
> In an ideal world, we would always use Windows authentication. In many cases, however, this is not possible. Many applications rely on SQL authentication to access the instance.

A very common mistake made by accidental DBAs is to leave this configuration as is. But why is this a mistake? The issue is that `sa` is a well-known account, and it has full administrative permissions to the instance. This means that if a bad actor were to attack our instance, their first port of call would likely be to try and compromise the `sa` account.

To make matters worse, because of the nature of SQL logins, they are vulnerable to brute-force attacks. A *brute-force attack* is where an attacker programmatically tries to log in using a known login name and a password dictionary. They try each password in turn until one works. Because the `sa` account is well known, the attacker will have to do no work to try to figure out the name of an account with administrative permissions; they already know it. Therefore, they can just crack on with a brute-force attack against it.

So what should we do differently? Well, there are two options. First, we could simply disable the account. In this scenario, we will ensure that we have other security principals (ideally, Windows users via an AD group) in the `sysadmin` server role. These administrative accounts can be used instead of relying on `sa`. The following listing demonstrates how to disable the `sa` account.

Listing 14.3 Disabling the `sa` account

```sql
ALTER LOGIN sa DISABLE ;
```

Alternatively, we could choose to keep the `sa` account but rename it. If we take this approach, the account will retain its administrative permissions but will no longer have a well-known name. This makes it harder for a bad actor to attack but not impossible. If they manage to discover the name of the account, it is still subject to brute force. This means that, while this improves security, it is not as effective as disabling the account and using Windows authentication for administrators.

WARNING Any SQL login is subject to brute-force attack. We should avoid granting elevated permissions to SQL logins wherever possible.

The command in the following listing demonstrates how to rename the `sa` account.

Listing 14.4 Renaming the `sa` account

```sql
ALTER LOGIN sa
    WITH NAME = InstanceAdmin ;
```

sa configuration

When working with SQL logins, especially `sa`, it is a good idea to make them as secure as possible. A nice feature of SQL Server is it can enforce the domain password policy and expiration for SQL logins. This will ensure that password complexity is adhered to and also force passwords to be rotated. The following command demonstrates how to enforce domain password policy and expiration:

```sql
ALTER LOGIN InstanceAdmin
    WITH CHECK_POLICY = ON
       , CHECK_EXPIRATION = ON ;
```

Because `sa` is a well-known account with full administrative permissions to the instance, it is likely to be the first port of call for a bad actor who wants to attack our instance. To keep our instance as secure as possible, we should disable the `sa` account. If this is not possible, then we should rename the account.

## 14.3 #96 Using the wrong granularity of a service account

Defining a strategy for service accounts has historically caused a lot of debate. From a purist security perspective, the ideal would be to have a different service account for every single service on every single SQL Server instance. Therefore, if you imagine that you have three SQL Servers, each running the Database Engine, SQL Server Integration Services, and SQL Server Analysis Services, you would have a total of nine service accounts.

The trouble with this approach, which we call a *fine-grain strategy*, is that it quickly becomes a real headache to manage. If we have a SQL Server estate with 200 instances spread across 150 servers, each running an average of two services, then we suddenly need to manage 400 accounts across 150 servers. Although automatic password expiration is usually disabled for service accounts, these are often highly privileged accounts, and we still need to rotate all the passwords on a regular basis.

To make matters worse, this can often involve synchronizing a change across AD or SQL Server resources and sometimes even other changes such as application configuration files or registry keys. When we go with this level of granularity, usually passwords never get rotated and, although the fine grain avoids lateral movement between instances and features, it still increases the security risk exposure for individual resources. Some of these will be business critical, and if our organization is subject to regulatory compliance, we may need to demonstrate that passwords are rotated.

This often leads to organizations going to the other end of the scale, where they have a single (or very few) service accounts managing vast numbers of instances and features. This is known as a *coarse-grain strategy*. This is even worse than a fine-grain strategy. It means that if the service account is compromised, the attacker has access to our entire SQL Server estate. What’s more, it usually means that the password still doesn’t get rotated, because it is impossible to coordinate the change across that many applications at the same time.

The mistake that DBAs make is not realizing that Microsoft solved this conundrum back in Windows Server 2012, when it introduced Group Managed Service Accounts (gMSA). These are a special kind of service account with simplified management of service principal names and automatic password rotation. The passwords are highly complex and stored inside AD. These passwords are never exposed to administrators. The accounts are entirely self-managed, and they also cannot be used interactively. These features combined make them far more secure than traditional service accounts.

An AD administrator will create a gMSA in AD, and then a script will be run on the server hosting SQL Server, which will authorize the server to use the account. The reason that DBAs do not tend to use these accounts is simply because many DBAs have not heard of them. There is simply no reason not to use them.

Holistically, the main advantage of gMSAs in our service account strategy is that they allow us to have a much coarser grain without exposing our organization to an increased security risk. Each organization will have its own standards for the exact grain that should be used for gMSAs, but as a starting point, I tend to segregate them by ecosystem and business division. There is no reason not to use gMSAs for SQL Server, and we should always use them instead of traditional service accounts.

## 14.4 #97 Enabling xp_cmdshell

`xp_cmdshell` is an extended stored procedure that allows administrators to execute commands in the operating system. It has long been considered a security risk, and it is disabled by default. The reason it is considered a security risk is because it allows for *lateral movement* from a SQL Server instance into the operating system. What’s more, it will run in the context of the SQL Server service account, which is usually a highly privileged account. If you have a coarse grain of service account (see section 14.3), then you may also allow lateral movement to other SQL Server instances.

Lateral movement

Lateral movement is a technique used by bad actors to exploit a vulnerability on one server to gain access to other servers. For example, if an attacker has gained access to a SQL Server instance, they could gain access to other SQL Server instances, either by spoofing over privileged credentials or by using linked servers.

Alternatively, an attacker could use `xp_cmdshell` to gain access to a server’s operating system from a vulnerable SQL Server instance. They could then use other attack techniques such as an SMB interception attack to expose credentials that have elevated access to other servers. This is illustrated in this sidebar figure.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437401/files/OEBPS/Images/CH14_F01_Carter.png)<br>

Lateral movement

Unfortunately, in recent times there has been a trend toward less experienced DBAs enabling the feature. The arguments for doing this are twofold. First, people argue that it is only members of the `sysadmin` server role who are permitted to use the feature, and DBAs can be trusted to use it responsibly. The second argument is that disabling `xp_cmdshell` does not improve security because members of the `sysadmin` server role can simply turn it back on. This means if a bad actor has compromised an administrative account, they can just enable it if they want to use it.

Let’s tackle each of those points in detail. First, let’s discuss the argument that only members of the `sysadmin` server role can use it and that they can be trusted to use it responsibly. The first point to make here is that it is incorrect that only members of the `sysadmin` role can use the feature. In reality, the requirements for running the stored procedure are as follows:

* Member of the `sysadmin` server role
* Granted the `CONTROL SERVER` permission on the SQL Server instance
* Granted `EXEC` permissions on `xp_cmdshell` (requires an `xp_cmdshell` proxy)
* Granted permissions to impersonate a user that meets any of the above requirements

It would be unusual for someone to gain access via any method other than `sysadmin`, so why does this matter? Well, it matters exactly because it would be unusual. Because it’s unusual, it’s also opaque. We may well be keeping a close eye on who is a member of `sysadmin`, but are we really keeping an eye on who has been directly granted the `CONTROL SERVER` permission or who has been granted the `IMPERSONATE` permission on another security principal?

When considering this, it is important to remember that more than 70% of attacks are internal and performed by a bad actor who works for, or previously worked for, the target organization—the very people who may have the opportunity to engineer a back door by using opaque permissions.

We must also consider why we need to use `xp_cmdshell`. If a DBA has permissions to the operating system, why would they not just use the operating system directly? In my experience, DBAs who advocate for the use of `xp_cmdshell` are usually those who, by company policy, are not allowed operating system permissions. In these cases, it is the DBAs themselves who are using `xp_cmdshell` as a back door to provide lateral movement to the operating system. This may not be a malicious attack, but we should consider any practice that breaks our organization’s security policy as bad, no matter how benign the intentions.

So let’s consider the second argument, which states that if you have permissions to use `xp_cmdshell`, then you have permissions to enable it. This is true in all cases, except where an `xp_cmdshell` proxy has been configured, and the user has been granted `EXECUTE` permissions on the stored procedure.

If we look at it on the surface, this sentiment is fair. Even if we make sure `xp_cmdshell` is disabled by using a data definition language (DDL) trigger or SQL Server policy-based management, then an administrator will have the permissions to disable that trigger or policy-based management policy prior to executing the procedure.

If we look deeper, however, we should consider layers of security. If `xp_cmdshell` is enabled, then it can easily be used. If it is disabled, then an attacker will first need to enable it. If we have a trigger preventing the feature from being enabled, this trigger will need to be deleted, then the procedure enabled, before damage can be done. Each of these layers takes time and increases the likelihood of the attack being spotted and stopped.

To this end, possibly the most important thing that we can do as DBAs is to ensure that alerting is in place to raise a P1 alert in the event that somebody attempts to enable `xp_cmdshell`.

Consider the script in listing 14.5. First, the script creates a custom error message warning that someone has tried to enable `xp_cmdshell`. It then creates a trigger that will catch this event. DDL triggers are created at the instance level and trigger in response to the execution of DDL commands. This trigger is set to respond to `ALTER_INSTANCE` events. When any `ALTER_INSTANCE` event fires, the trigger will be executed. The trigger reads the executed command text into a variable. It then uses the `CHARINDEX()` function to see if the statement contains the strings `sp_configure` and `xp_cmdshell`. If it does, then the custom error message we created at the start of the script is fired using the `WITH LOG` statement. This ensures the alert is sent to the SQL Server log and the Windows application event log. Finally, the script rolls back the transaction and prevents `xp_cmdshell` from being enabled.

Listing 14.5 Creating a trigger to prevent `xp_cmdshell` execution

```sql
EXEC sp_addmessage 50001, 16, 'Attempt to disable xp_cmdshell' ;
GO

CREATE TRIGGER prevent_xp_cmdshell
ON ALL SERVER
FOR ALTER_INSTANCE
AS
BEGIN
  DECLARE @Statement NVARCHAR(4000) ;

  SET @Statement = (SELECT EVENTDATA().value('(/EVENT_INSTANCE/TSQLCommand/CommandText)[1]',
'nvarchar(4000)')) ;

  IF (CHARINDEX('sp_configure', @Statement) > 0)
         AND (CHARINDEX('xp_cmdshell', @Statement) > 0)
  BEGIN
    RAISERROR(50001, 16, 1, 'Attempt to disable xp_cmdshell') WITH LOG ;
    ROLLBACK ;
  END
END ;
GO
```

We can now ask our observability team to create an alert in the event that error 50001 is raised to the event log. If our organization does not have an enterprise monitoring tool, then we can achieve the same results with SQL Agent alerts. An enterprise monitoring tool is preferable, however, to avoid having to run Database Mail.

> [!TIP]
>
> Alerting on errors is covered in chapter 7.

If we respond to this P1 security alert quickly, we will have an opportunity to catch the attack before it does any damage. It is far from perfect and certainly not risk free as an approach, but it is far better than allowing `xp_cmdshell` to be enabled and letting bad actors freely perform lateral movement and compromise other areas of our estate. As an added bonus, it will also keep the cyber security team and auditors happy, which will save us time in writing exception reports.

Each security team will have its own processes and policies for what to do if an active attack is discovered. My own personal approach, however, is to take down the instance while the incident is being investigated. This will cause an outage, but it is the best way to safeguard a company’s data.

It is worrying that `xp_cmdshell` is making its way back into the consciousness of accidental DBAs. It is a highly dangerous procedure that exposes our organizations to risk. Unfortunately, there is no way to entirely eliminate this threat, but we should minimize the risk by introducing layers of security. This involves ensuring that as few people have elevated permissions on the instance as possible by using the principle of least privilege. It means disabling dangerous features that we do not (or should not) use, such as `xp_cmdshell`, and making sure that robust alerting is in place so we stand a chance of preventing an attack from succeeding. Additionally, we should use auditing to ensure that privileged accounts have nonrepudiation. That is the perfect segue to our next mistake, which discusses this very subject.

## 14.5 #98 Failing to audit administrative activity

As mentioned previously in this chapter, we may not like to think about it, but the majority of cyberattacks are internal. When we consider this, we must remember that in large organizations there may be many people who have administrative access to SQL Server instances. Ideally, this would just be the DBA team, but as discussed earlier in this chapter, in some environments we may have a suboptimal security stance where other individuals, such as application developers or application support teams, also have administrative access. Even if we do manage to limit `sysadmin` membership to just DBAs, in many companies this will involve a combination of staff, contractors, and third-party managed services. We must also consider that, even if we are subject to an external attack, an administrative account could be compromised and used against us.

For these reasons, it is important that we ensure nonrepudiation. Every individual with privileged access must be accountable for their actions. Also, if an account has been compromised and is being used to perform an attack, we must be able to quickly identify this and take measures (such as disabling the account) to avoid the attack from continuing.

SQL Server allows us to ensure nonrepudiation by auditing administrative activity with a lightweight auditing tool called SQL Server audit. This tool can be configured to write audit actions to the Windows security log to prevent SQL Server administrative users from tampering with it. The majority of environments I see do not have SQL Server audit configured, however, and this is a mistake that any security-conscious DBA should immediately resolve.

To capture administrative actions in a tamper-proof way, there are some prerequisite steps that need to be taken. In many organizations, DBAs will need to ask for support from the Windows team with these prerequisites:

* The audit object access setting must be configured to allow *application-generated* audit events. This can be achieved using the auditpol command-line utility.
* The SQL Server service account must be granted the *generate security audits* user rights assignment. This can be achieved in the `secpol.msc` snap-in.
* The audit policy must be configured to allow the *audit object* policy to audit success and failure. This can also be performed in the `secpol.msc` snap-in.

> [!TIP]
>
> The server should be restarted after these changes are made.

These prerequisite steps allow for SQL Server to write audit events to the Windows security log, which cannot be tampered with by members of the `sysadmin` server role. Once these steps are complete, we can create an audit in SQL Server. This audit object specifies where we want to store the audit results and the action that should be taken if there is a failure writing to the audit log. This action can be set to continue, fail operation, or shut down the server. The command in the following listing demonstrates how to create an audit that will save the logs in the Windows security log.

Listing 14.6 Creating an audit object

```sql
USE master ;
GO

CREATE SERVER AUDIT AdminActivityAudit
TO SECURITY_LOG WITH (
      ON_FAILURE = CONTINUE
) ;
```

We now need to create an audit object specification. This is where we define what activity we would like to audit. The list of audit action types is expansive, covering almost any action that can be performed in SQL Server. At the instance level, this covers everything from backup–restore operations, login attempts, and database creation or deletion. At the database level, everything from a batch starting to changing a schema owner can be captured. The full list of action types is too vast to include in these pages, but a full list can be found at <https://mng.bz/9on1>.

Table 14.2 lays out the action types that we will want to audit for our use case.

Table 14.2 Audit action types

| Audit action type | Description |
| --- | --- |
| `AUDIT_CHANGE_GROUP` | The event is raised when an audit is created, dropped, or altered. Adding this will ensure nonrepudiation if an administrative user tries to shut down an audit, perform a nefarious activity, and then reenable it. |
| `DBCC_GROUP` | The event is raised when a DBCC statement is run. |
| `SERVER_OBJECT_CHANGE_GROUP` | The event is raised when an instance-level object is created, dropped, or altered. |
| `SERVER_OBJECT_PERMISSION_CHANGE_GROUP` | The event is raised when permissions are assigned to or revoked from a schema-bound object. |
| `SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP` | The event is raised when the owner of an instance-level object is changed. |
| `SERVER_OPERATION_GROUP` | The event is raised when instance configuration changes are made. |
| `SERVER_PERMISSION_CHANGE_GROUP` | The event is raised when permissions are assigned to or revoked from instance-level permissions. |
| `SERVER_PRINCIPAL_CHANGE_GROUP` | The event is fired when instance-level principals are created, dropped, or altered. |
| `SERVER_PRINCIPAL_IMPERSONATION_GROUP` | The event is raised when impersonation of an instance-level principal occurs. |
| `SERVER_ROLE_MEMBER_CHANGE_GROUP` | The event is raised when the membership of a server role is changed. |
| `SERVER_STATE_CHANGE_GROUP` | The event is raised when the state of the instance is modified. |

To create this audit specification, we can use the command in the next listing. > [!NOTE]
>
> that the `FOR SERVER AUDIT` clause links the audit specification to our audit object.

Listing 14.7 Creating an audit specification

```sql
CREATE SERVER AUDIT SPECIFICATION AdminActivitySpecification
FOR SERVER AUDIT AdminActivityAudit
    ADD (SERVER_ROLE_MEMBER_CHANGE_GROUP),
    ADD (AUDIT_CHANGE_GROUP),
    ADD (DBCC_GROUP),
    ADD (SERVER_OBJECT_PERMISSION_CHANGE_GROUP),
    ADD (SERVER_PERMISSION_CHANGE_GROUP),
    ADD (SERVER_PRINCIPAL_IMPERSONATION_GROUP),
    ADD (SERVER_OBJECT_CHANGE_GROUP),
    ADD (SERVER_PRINCIPAL_CHANGE_GROUP),
    ADD (SERVER_OPERATION_GROUP),
    ADD (SERVER_STATE_CHANGE_GROUP),
    ADD (SERVER_OBJECT_OWNERSHIP_CHANGE_GROUP) ;
```

Database audit specifications

As well as auditing instance-level activity with a server audit specification, we can also audit database-level activity with a database audit specification. These objects are again attached to an audit object but allow for fine-grain auditing of every activity, down to `SELECT` statements. If we have multiple databases that we wish to audit, we will need to create the database audit specification in each database.

We need to be a little careful of performance. Despite the fact that SQL Server audit is a lightweight tool, if we audit too many unnecessary events, we can have a performance impact on a busy server. Generally speaking, low-level auditing is reserved for compliance requirements or specific use cases.

Because of the nature of accounts with `sysadmin` permissions, we should always introduce an audit of administrative activity at the instance level to ensure nonrepudiation if we come under internal attack. This also helps us isolate an account that has been compromised if we come under external attack. We can audit privileged actions using SQL Server audit, and we can ensure the logs are not tampered with by saving the audit records to the Windows security log.

## 14.6 #99 Exposing the business to whole-value substitution attacks

SQL Server provides multiple ways to encrypt data to protect against different attack scenarios. This includes transparent data encryption, which provides protection from a bad actor “stealing” a database and trying to attach it or restore it to a different instance. It also includes Always Encrypted, which prevents even members of the `sysadmin` server role from decrypting and viewing data. This is helpful in highly secure environments with extremely sensitive data.

In this section, however, we focus on cell-level encryption and a common mistake that is made when configuring this type of encryption, which allows us to encrypt certain sensitive data such as credit card numbers. The specific mistake that we will explore is leaving our organizations open to a whole-value substitution attack. This is an attack where a bad actor replaces an encrypted value with a different encrypted value that they believe will benefit them or allow them to perform a nefarious action such as credit card fraud.

WARNING Cell-level encryption should always be used sparingly. It can cause serious performance degradation as well as up to 4,000% bloat. It is usually reserved for compliance reasons or for very specific use cases.

To understand what a whole-value substitution attack is, let’s use the `HumanResources` database that we created in chapter 3. This database contains a table called `Employees`, which stores all of the employee records for the fictional company MagicChoc. Let’s imagine that our human resources department has decided that the `Salary` column of this table is highly sensitive and must be encrypted.

In the next section, we will prepare an encrypted environment that we can use, and in the following section we will explore what a whole-value substitution attack is and how we can prevent it.

### 14.6.1 Preparing an encrypted environment

To meet this requirement, we will first need to create the encryption hierarchy of objects that will be required. This starts with a Service Master Key, which is encrypted using the Windows Data Protection API and is the encryption root within the SQL Server instance. This key is used to encrypt the database master key, which is the encryption root within a specific database. The database master key is then used to encrypt asymmetric keys and certificates within the database. At the bottom of the hierarchy are symmetric keys. These symmetric keys are encrypted using a certificate or asymmetric key and are used to encrypt the data. This hierarchy is illustrated in figure 14.1.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437401/files/OEBPS/Images/CH14_F02_Carter.png)<br>
**Figure 14.1 SQL server encryption hierarchy**

Symmetric vs. asymmetric keys

While a full explanation of cryptography is beyond the scope of this book, it is always useful to understand the difference between a symmetric key and an asymmetric key. A symmetric key has a single key, which is secret and is used to both encrypt and decrypt data. An asymmetric key, on the other hand, has a secret key (known as a private key) that decrypts data but a different, public key that is used for data encryption.

This difference in approach, which is illustrated in the figure in this sidebar, makes asymmetric encryption more secure but also adds additional overhead. This is why a symmetric key is often used to encrypt the data.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437401/files/OEBPS/Images/CH14_F03_Carter.png)<br>

Symmetric vs. asymmetric keys

The service master key is automatically created the first time the SQL Server instance is started, but the script in listing 14.8 demonstrates how to create a database master key in the `HumanResources` database along with a certificate and symmetric key. The certificate is encrypted using the database master key. You will notice that the script also takes a backup of the database master key, and the symmetric key is encrypted using the certificate. This is very important, because if we lose this key, then we lose access to all data that is encrypted below it in the hierarchy.

Listing 14.8 Creating the encryption hierarchy

```sql
USE HumanResources ;
GO

CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'Pa$$w0rd' ;           ①
GO

OPEN MASTER KEY DECRYPTION BY PASSWORD = 'Pa$$w0rd';
BACKUP MASTER KEY TO FILE = 'c:\keys\HumanResourcesMasterKey.key' ②
    ENCRYPTION BY PASSWORD = 'Pa$$w0rd' ;
GO

CREATE CERTIFICATE SalaryCert                                     ③
WITH SUBJECT = 'Employee Saleries' ;
GO

CREATE SYMMETRIC KEY SalaryKey                                    ④
WITH ALGORITHM = AES_128
ENCRYPTION BY CERTIFICATE SalaryCert ;
GO
```

① Creates database master key

② Backs up database master key

③ Creates a certificate

④ Creates a symmetric key

The next step is to prepare the table by adding a column called `EncryptedSalary`, which will have a data type of `VARBINARYY(8000)`. Encrypted values are always stored as `VARBINARY`. This column will be used to store the encrypted values and can be added by using the command in the following listing.

Listing 14.9 Adding the `EncryptedSalary` column

```sql
ALTER TABLE dbo.Employees
    ADD EncryptedSalary VARBINARY(8000) ;
```

The script in listing 14.10 will populate the `EncryptedSalary` column by updating the column to add the encrypted version of the salary. To do this, the script first opens the symmetric key. It then uses the `ENCRYPTBYKEY()` function to encrypt the data. The first parameter passed to the function is the globally unique identifier (GUID) of the symmetric key. To avoid needing to look this up, the script embeds a function called `KEY_GUID()`. We pass this function the name of the symmetric key and it returns the key’s GUID. The second parameter of the `ENCRYPTBYKEY()` function is the data that we want to encrypt. In this case, it is the `Salary` column. Finally, the script closes the symmetric key to prevent it from being used by another query.

Listing 14.10 Populating the `EncryptedSalary` column

```sql
OPEN SYMMETRIC KEY SalaryKey
DECRYPTION BY CERTIFICATE SalaryCert ;

UPDATE dbo.Employees
    SET EncryptedSalary =
        ENCRYPTBYKEY(KEY_GUID('SalaryKey'), CAST(Salary AS VARCHAR(10))) ;

CLOSE SYMMETRIC KEY SalaryKey ;
```

> [!NOTE]
>
> In a production environment, we would drop the `Salary` column so that the data is no longer stored in clear text.

### 14.6.2 Understanding and preventing whole-value substitution attacks

To understand a whole-value substitution attack, imagine that MagicChoc has unwittingly hired a dishonest person. Robin Round is the recruitment manager. He works in the human resources department, and therefore he has `SELECT` and `UPDATE` permissions on the `Employees` table. If Robin runs a `SELECT` statement against the table, he will be able to see employee details, such as their name and role. He will also be able to return the encrypted salary column, although the results will be a meaningless encrypted value.

While Robin is not able to determine what salary Bob Walford (the CEO) receives, he knows that it will be far more than his own salary. This means that if he updates his own salary to have the same encrypted value as Bob Walford’s, he will simply bypass all of our encryption and give himself a very large pay raise! This is known as a whole-value substitution attack and is demonstrated in the following listing.

Listing 14.11 Performing a whole-value substitution attack

```sql
UPDATE dbo.Employees
SET EncryptedSalary =
(
    SELECT EncryptedSalary
    FROM dbo.Employees
    WHERE FirstName = 'Bob'
        AND LastName = 'Walford'
)
WHERE FirstName = 'Robin'
    AND LastName = 'Round' ;
```

The query in the following listing uses the `DECRYPTBYKEY()` function to decrypt the `EncryptedSalary` column and show that Robin Round and Bob Walford now have the same salary.

Listing 14.12 Assessing the impact of the attack

```sql
OPEN SYMMETRIC KEY SalaryKey
DECRYPTION BY CERTIFICATE SalaryCert ;

SELECT
      FirstName
    , LastName
    , Role
    , CAST(CONVERT(VARCHAR(10),DECRYPTBYKEY(EncryptedSalary)) AS MONEY)
FROM dbo.Employees
WHERE (FirstName = 'Bob' AND LastName = 'Walford') OR
      (FirstName = 'Robin' AND LastName = 'Round') ;

CLOSE SYMMETRIC KEY SalaryKey ;
```

Running this query will show that both people now have a salary of $96,000.

So what should we have done differently? Well, we can protect against this attack pattern by adding what is known as an *authenticator column*. This designates an additional value, often the primary key of the table, to be encrypted alongside the sensitive data. This authenticator is then checked when the value is updated to ensure that it matches.

To understand this better, let’s use the script in listing 14.13 to add another column to the `Employees` table. It is called `EncryptedSalaryWithAuth`, and the script populates it by encrypting the `Salary` column. This time, however, we use the `EmployeeID` column as an authenticator.

Listing 14.13 Encrypting salaries with an authenticator

```sql
ALTER TABLE dbo.Employees
    ADD EncryptedSalaryWithAuth VARBINARY(8000) ;
GO

OPEN SYMMETRIC KEY SalaryKey
DECRYPTION BY CERTIFICATE SalaryCert ;

UPDATE dbo.Employees
        SET EncryptedSalaryWithAuth =
            ENCRYPTBYKEY(
                Key_GUID('SalaryKey'),
                CAST(Salary AS VARCHAR(10)),
                1,
                CAST(EmployeeID AS VARBINARY(8000))
            ) ;

CLOSE SYMMETRIC KEY SalaryKey ;
```

With this in place, let’s use the query in the following listing to simulate the attack again—this time against the `EncryptedSalaryWithAuth` column.

Listing 14.14 Simulating the attack with an authenticator

```sql
UPDATE dbo.Employees
SET EncryptedSalaryWithAuth =
(
    SELECT EncryptedSalaryWithAuth
    FROM dbo.Employees
    WHERE FirstName = 'Bob'
        AND LastName = 'Walford'
)
WHERE FirstName = 'Robin'
    AND LastName = 'Round' ;
```

We can now use the query in the following listing to assess the impact of this attack.

Listing 14.15 Assessing the impact of the attack with authenticator column

```sql
OPEN SYMMETRIC KEY SalaryKey
DECRYPTION BY CERTIFICATE SalaryCert ;

SELECT
      FirstName
    , LastName
    , Role
    , CAST(
          CONVERT(
              VARCHAR(10),
              DECRYPTBYKEY(
                  EncryptedSalaryWithAuth,
                  1 ,
                  CONVERT(VARBINARY, EmployeeID)
              )
          ) AS MONEY
      )
FROM dbo.Employees
WHERE (FirstName = 'Bob' AND LastName = 'Walford') OR
      (FirstName = 'Robin' AND LastName = 'Round') ;

CLOSE SYMMETRIC KEY SalaryKey ;
```

Executing this query will show that Robin’s salary now shows as a `NULL` value. Although he was able to update the encrypted salary value, the decryption no longer works because the authenticator doesn’t match. This means that the attack was unsuccessful.

Encryption can be a very useful tool for protecting sensitive data. It should be used sparingly, because if it’s used widely it can cause significant bloat and performance issues. When it is used to encrypt very sensitive data, we should ensure that we do not leave our organization open to whole-value substitution attacks. These attacks involve a bad actor replacing an encrypted value with a different encrypted value. Adding an authenticator column can prevent this attack pattern from succeeding.

## 14.7 #100 Exposing the business to SQL injection attacks

SQL injection is an attack pattern in which the attacker will attempt to enter T-SQL statements in the fields of an application where standard user input is expected. This results in the application building valid but unintended and often harmful statements. These statements will be designed to cause serious damage to the SQL Server environment and often to perform lateral movement to other environments.

A mistake that I see often among accidental DBAs is a belief that this form of attack is something that they do not need to worry about. Instead, they believe that all of the responsibility lies with the application developers to ensure that their applications correctly validate all input.

To a certain extent, this is right. So to understand why this is a mistake, let’s use the analogy of a museum that hires a night watchman. Just because they have hired a night watchman, does this mean that when they close up for the day, they will leave all of the doors unlocked and turn off the alarms on the cases that house priceless artifacts? No, of course not. This would dramatically increase the risk that a burglar will simply sneak in while the night watchman is doing his rounds on a different floor.

It is vitally important for DBAs to remember that they are the last line of defense for an organization’s data. Yes, of course, application developers should be validating input in their applications, but we cannot guarantee that they are doing this. We certainly cannot guarantee that an application developer hasn’t simply made a mistake that did not get picked up during testing.

To understand why protecting against SQL injection is so important, let’s take a little time to understand how attacks are performed and the damage they can do. To this end, let’s set up a very basic, insecure web page with an insecure SQL Server configuration in the backend.

The examples in this section assume that these poor practices have been followed:

* The service account is in the `Administrators` group in Windows.
* The service account is a member of the `sysadmins` server role.
* `xp_cmdshell` is enabled.
* The instance uses mixed-mode authentication but doesn’t disable or rename the `sa` account.
* The SQL logins are not set to enforce domain password policy.
* The web app has no input validation.
* The web app uses the `sa` account to connect to the database.
* The web app stores the username and password in code, in clear text.
* The web app builds SQL dynamically.

> [!TIP]
>
> An additional security concern that should be noted is that user passwords are stored in plain text in the `Users` table. Passwords should usually be encrypted.

The script in listing 14.16 creates a database called `SQLInjection`, which contains a table called `Users`. This table is populated with two usernames and passwords. The website we create will assume that the database resides in the default instance. If you want to use a named instance, just update the connection string in the C# file accordingly.

Listing 14.16 Creating the `SQLInjection` database

```sql
CREATE DATABASE SQLInjection ;
GO

USE SQLInjection ;
GO

CREATE TABLE dbo.Users
(
    ID              INT              NOT NULL    IDENTITY    PRIMARY KEY,
    UserName        NVARCHAR(128)    NOT NULL,
    UserPassword    NVARCHAR(512)    NOT NULL
) ;
GO

INSERT INTO dbo.Users(UserName, UserPassword)
VALUES('Pete', 'Password1'),
      ('Terri', 'MyPassword') ;
GO
```

The script in listing 14.17 provides the code for a very basic login page and a basic welcome page. To follow this example, you will need to create a C#-based ASPX Web Forms project in Visual Studio. You should then add two web forms to the project and copy the code for each.

> [!TIP]
>
> If you are using Visual Studio 2022, Microsoft will steer you down the path of Razor. This demonstration uses the ASP.NET Web Application (.NET Framework), however. To access this, ensure that you have the Additional Project Templates (Previous Versions) component installed. When you create the project, use the Web Forms option.

Listing 14.17 Code for login page and welcome page

```sql
<%@ Page Language="C#" AutoEventWireup="true" CodeBehind="Login.aspx.cs" Inherits="SQLInjection.Login" %>                                   ①

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
    <title></title>
    <style type="text/css">
        .auto-style1 {
            width: 503px;
            height: 249px;
            margin-left: 67px;
        }
    </style>
</head>
<body>
    <form id="form1" runat="server">
    <div style="margin-left: 280px">

        <br />
        <br />
        <asp:Login ID="Login1" runat="server" Height="244px" OnAuthenticate="Login1_Authenticate" Width="483px" BackColor="#EFF3FB" BorderColor="#B5C7DE" BorderPadding="4" BorderStyle="Solid"
BorderWidth="1px" Font-Names="Verdana" Font-Size="0.8em"
ForeColor="#333333" style="margin-left: 64px">
            <InstructionTextStyle Font-Italic="True" ForeColor="Black" />
            <LoginButtonStyle BackColor="White" BorderColor="#507CD1" BorderStyle="Solid" BorderWidth="1px" Font-Names="Verdana" Font-
Size="0.8em" ForeColor="#284E98" />
            <TextBoxStyle Font-Size="0.8em" />
            <TitleTextStyle BackColor="#507CD1" Font-Bold="True" Font-Size="0.9em" ForeColor="White" />
        </asp:Login>
        <br />
        <br />
        <asp:Label ID="Label1" runat="server"></asp:Label>
        <br />

    </div>
    </form>
</body>
</html>

<%@ Page Language="C#" AutoEventWireup="true" CodeBehind="Welcome.aspx.cs"
 Inherits="SQLInjection.Welcome" %>                                ②

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
    <title></title>
    <style type="text/css">
        .auto-style1 {
            width: 856px;
            height: 336px;
            margin-left: 235px;
        }
    </style>
</head>
<body>
    <form id="form1" runat="server">
    <div>
    </div>
        <br />
        <asp:Label ID="Label2" runat="server" Text="Welcome!"></asp:Label>
    </form>
</body>
</html>
```

① Code for Login.aspx

② Code for Welcome.aspx

We can then use the code in listing 14.18 to create the C# files that sit behind the ASPX files. Again, to follow along, you can just copy and paste the code.

> [!NOTE]
>
> The code for Welcome.aspx.cs is just an empty placeholder. It doesn’t provide any functionality.

Listing 14.18 Code for C# files behind the ASPX files

```sql
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Data;
using System.Data.SqlClient;
using System.Reflection.Emit;

namespace SQLInjection
{
    public partial class Login : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {

        }

        protected void Login1_Authenticate(object sender, AuthenticateEventArgs e)
        {
            SqlConnection con = new SqlConnection(@"Data Source=.;Initial
Catalog=SQLInjection;Integrated Security=False;Uid=sa;Pwd=Pa$$w0rd");
            string qry = "SELECT * FROM Users WHERE UserName='" +
Login1.UserName + "'AND UserPassword='" + Login1.Password + "' ";
            SqlDataAdapter adapter = new SqlDataAdapter(qry, con);
            DataTable datatable = new DataTable();
            adapter.Fill(datatable);
            if (datatable.Rows.Count >= 1)
            {
                Label1.Visible = false;
                Session["Parameter"] = datatable.Rows[0].Field<string>(1);

                Response.Redirect("Welcome.aspx");
            }
        }
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace SQLInjection
{
    public partial class Welcome : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {

        }
    }
}
```

If we were to use this website as designed, then we would enter our username and password and be directed to the welcome page. If we were a bad actor wanting to attack the organization, however, then we would perform a SQL injection attack. To understand this attack, we need to understand that if we were to log in as the user `Pete`, then the application would build the following query:

```sql
SELECT * FROM Users WHERE UserName='Pete' AND UserPassword='Password1' ;
```

If, however, instead of typing a username, the attacker entered `' OR 1=1--` into the username field and some random characters into the password field, then the query would become

```sql
SELECT * FROM Users WHERE UserName='' OR 1=1-- ' AND
UserPassword='randomchars' ;
```

Because everything to the right of `--` is a comment and not executed and because 1 always equals 1, all users in the table will be passed into the dataset and C# will use the first row to be returned. In short, the attacker has just spoofed the identity of the first user in the table.

In a more sophisticated attack, a bad actor could leak information such as the database name, instance name, or even the AD domain to give them the required information to perform further attacks. For example, if the bad actor were to use `' or 1 = db_name()--`, then the resulting error message would include the following:

```sql
Conversion failed when converting the nvarchar value 'SQLInjection' to data
type int
```

You will see that this has leaked the database name, `SQLInjection`. If the bad actor wanted to perform a lateral movement attack, then, because of our insecure configuration, they could simply use the command `' AND 1=1; EXEC xp_cmdshell 'net user hacker WeakPa$$w0rd /ADD'--` in the username field. The result would be that a new user called `hacker` is created on our server. This user can then be used to perform further downstream attacks against our network.

How can we protect our organization against such attacks? The primary answer to this is to follow the advice in this chapter and security recommendations in general. There is an additional protection mechanism that we can take, however, which is to enforce coding standards.

If we mandate that web applications must use stored procedures, rather than building SQL dynamically, we can prevent this form of attack. For example, consider the stored procedure in the following listing. The procedure accepts variables for username and password, which would be passed by the application.

Listing 14.19 Creating a login stored procedure

```sql
CREATE PROCEDURE dbo.Login
      @UserName NVARCHAR(128)
    , @Password NVARCHAR(128)
AS
BEGIN
    SELECT *
    FROM dbo.Users
    WHERE UserName = @UserName
        AND UserPassword = @Password ;
END
```

The simple procedure uses the same logic as the dynamically built SQL from the website, but let’s see what happens if we run the script in listing 14.20. The script first simulates the correct use of the stored procedure, where a valid username and password are passed in. It then simulates an attack by a bad actor trying to spoof a password.

Listing 14.20 Simulating the use of a login stored procedure

```sql
DECLARE @UserName NVARCHAR(128) = 'Pete' ;
DECLARE @Password NVARCHAR(128) = 'Password1' ;

EXEC dbo.Login @username, @password ;              ①

SET @UserName = ''' OR 1=1--' ;
SET @Password = 'randomchars' ;

EXEC dbo.Login @username, @password ;              ②
```

① Simulates execution as a normal user

② Simulates execution as a bad actor

You will notice that the first invocation of the stored procedure returns the desired results. The second invocation of the stored procedure does not return any results. This will result in the attack failing.

> [!TIP]
>
> An advantage of enforcing stored procedures, as opposed to having strict validation on a field in a web app, is that it prevents a poor user experience for people who have double-barreled last names without the website input validation becoming overly complicated.

SQL injection is a common form of attack in which a bad actor will attempt to use a weak security posture to perform malicious actions. These malicious actions could range from spoofing another user to destructive attacks that delete data or drop tables. Such an attack can even be used to perform lateral movement to other areas of our network. We should always implement security best practices to avoid such attacks. We should also consider enforcing coding standards, which prevent this attack pattern from succeeding.

## Summary

* The principle of least privilege states that any person should only have the level of permissions they require to perform their day-to-day tasks.
* If someone needs to perform an action outside of their normal activities, then they should have their permissions increased and then revoked when the task is complete.
* Push back against third-party software providers who claim to need `sysadmin` permissions.
* The `sa` account is a well-known, highly privileged account. Therefore, it is often subject to attack.
* If your instance uses mixed-mode authentication, disable or rename the `sa` account.
* Group Managed Service Accounts (gMSAs) should be used instead of traditional service accounts.
* gMSAs are more secure than traditional service accounts and also simplify security operations.
* `xp_cmdshell` should not be enabled. SQL Server is best secured through multiple layers of protection.
* `xp_cmdshell` opens the door for attackers to perform lateral movement attacks and gain access to the server’s operating system.
* Configure a P1 alert that fires if anyone attempts to enable `xp_cmdshell`. This gives an early warning that could prevent an attack from being successful.
* Audit administrative activity of your SQL Server instances. This ensures nonrepudiation and also helps you stop an attack if a privileged account has been compromised.
* You can use SQL audit to provide a lightweight mechanism for auditing administrative activity.
* Use cell-level encryption sparingly, because it can cause substantial bloat and performance issues. It is a good tool for securing highly sensitive data, however.
* A whole-value substitution attack describes an attacker replacing an encrypted value with a different encrypted value that they believe will benefit them.
* Whole-value substitution attacks can be used to perform nefarious activity such as credit card fraud.
* If you use cell-level encryption, consider using an authenticator column, which will prevent whole-value substitution attacks.
* SQL injection is a common attack pattern in which a bad actor will insert malicious SQL commands into an application that builds SQL dynamically.
* SQL injection attacks can be used to spoof user identities, leak information, destroy data, and perform lateral movement to other network resources.
* You can mitigate the risk of SQL injection attacks by ensuring you have a strong security posture.
* You can also protect against SQL injection attacks by enforcing coding standards, such as insisting applications access data via stored procedures as opposed to dynamically building SQL.
