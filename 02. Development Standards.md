# 2 Development standards

This chapter covers

* An introduction to development standards
* Naming standards
* Coding standards

In this chapter, we will explore why having (and following!) development standards is so important. So let’s start by defining exactly what we mean when we talk about development standards in the context of building data-tier applications with SQL Server. Development standards cover the following areas:

* Naming conventions
* Coding standards

  + Stylistic
  + Technical

Specifically, we will look at the common mistakes that database professionals make and discuss how you can avoid the same pitfalls.

## 2.1 An example mistake

Imagine the topology depicted in figure 2.1. Suppose you get a call from the application team that looks after an application called TimeChewer. They report that some of their queries are running slowly and ask you to take a look. They advise that the application’s database is hosted on the server called `sql-shared-app-server`.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437401/files/OEBPS/Images/CH02_F01_Carter.png)<br>
**Figure 2.1 A SQL Server topology with poor naming conventions**

You connect to the server, and your heart immediately sinks. The instances are called SQL01 and SQL02. This gives you no indication of which instance may host the application’s database. So you connect to each instance in turn, hoping to find a database with a name like “TimeChewer.” Unfortunately, you are greeted with database names DB01, DB02, DB03, and DB04.

Now you must contact the application team and ask them to find the connection string and work out which database and which instance the application is connecting to. Finally, they respond and let you know that TimeChewer is connecting to DB03 on SQL01. So you decide to have a look at one of the stored procedures that they have mentioned is performing badly and script out the stored procedure definition. The definition of this procedure is

```sql
ALTER PROCEDURE dbo.proc01
AS
BEGIN
;with t3 as (select col1, col2, col3 from tbl03) select t1.col1, t2.col2, t1.col2, t1.col3, t3.col1, t3.col2 from dbo.tbl01 t1 inner join tbl02 t2 on t1.col1 = t2.col1 and t1.col3 < 55 inner join t3 on t3.col1 = t1.col1 union select col1, col2, col3, NULL, NULL, '0' from dbo.tbl04 ;
END
```

I imagine you have just been squinting at the stored procedure, trying to work out what on earth it’s doing. In short, after spending 30 minutes trying to work out which database has the problem, you are now going to have to spend another 15 minutes reformatting the code into something legible and trying to work out what this very simple stored procedure is doing. That’s 45 minutes wasted, before you even start to investigate the problem.

While this is an extreme example, it illustrates why naming conventions and coding standards are so important and why failing in this area will leave you and others pulling their hair out in frustration.

## 2.2 #1 Nondescriptive object names

Although the example of nondescriptive database names in the introduction to this chapter was rather extreme, I have seen instances of people using SQL01, SQL02, etc. as their standard naming convention—for instance names—and it really does cause a headache. Nondescriptive naming is more prevalent, however, at the code level, and that is where we focus in this chapter.

> [!TIP]
>
> We will talk more about the specific problems caused by poor instance naming in chapter 8.

To discuss this, let’s head back to our MagicChoc example that we introduced in chapter 1. In this chapter, we will be discussing the `SalesDB` database, which is the backend for the website. Figure 2.2 illustrates the component diagram of this database, which shows the database objects (tables, procedures, and views) within this database.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437401/files/OEBPS/Images/CH02_F02_Carter.png)<br>
**Figure 2.2 `SalesDB` component diagram**

You will notice that the object names in this database really have not been well thought out. You should always strive to have code that is self-documenting. Contrary to popular belief, this does not necessarily mean littering the code with comments. Comments can certainly be helpful to explain complex logic, but far more important is that the code is written and structured in such a way that anybody who reads the code, providing that they are fluent in the language, can establish what the code is trying to achieve. Meaningful object names are a big part of this listing.

Imagine that you have been asked to fix a bug in the procedure that updates the stock inventory system after an order has been placed. You are not familiar with the process, so your first port of call might be to run a query that returns a list of stored procedures within the database. The following listing demonstrates three ways that you might wish to perform this activity. All three queries will return the same results.

Listing 2.1 Returning a list of stored procedures

```sql
SELECT
    name
FROM sys.procedures ;                      ①

SELECT
    name
FROM sys.objects                           ②
WHERE type_desc = 'SQL_STORED_PROCEDURE' ; ②

SELECT
    name
FROM sys.objects                           ③
WHERE type = 'P' ;                         ③
```

① Pulls the list from the sys.procedures catalog view

② Pulls the list from the sys.objects catalog view, filtering by the type description

③ Pulls the list from the sys.objects catalog view, filtering by the type

Of course, you may also choose to use SQL Server Management Studio (SSMS) to view the procedures through the GUI. However you decide to list the objects, you will find that there are procedures called `updateStock` and `stockUpdate`. Which is the procedure you need to debug? Who knows? Before you can start your assignment, you will need to either review the definitions of both stored procedures or find out where the procedure is being called to establish the name of the relevant procedure.

In our case, establishing where the stored procedure is called is going to be a little tricky because it is actually called by another stored procedure—the `sp_orders` stored procedure. Again, this procedure has a generic, fairly meaningless name, which does not articulate the purpose of the procedure. So you will have to track back to the application that triggered the process to discover the first procedure in the chain.

Now let’s imagine that you have worked out that the `orders` procedure is the first stored procedure in the chain. You can find the definition of this stored procedure through SSMS, or by running the query in the following listing.

Listing 2.2 Getting the stored procedure definition

```sql
SELECT s.definition
FROM sys.objects o
INNER JOIN sys.sql_modules s               ①
    ON o.object_id = s.object_id           ①
WHERE o.name = 'sp_orders' ;
```

① Joins sys.sql_modules, which stores the procedure definition to sys.objects, which stores the object name. The join is made on the object_id column, which is present in both catalog views.

> [!TIP]
>
> Personally, I prefer to script a stored procedure definition from Object Explorer in SSMS, as opposed to pulling the definition from the `sys.sql_modules` catalog view. This is because pulling from `sys.sql_modules` will not preserve the formatting.

The definition of the `sp_orders` stored procedure can be found in listing 2.3. The `@AddressID` parameter is meaningless. Is it the billing address or the delivery address? The `@Address` parameter is both meaningless and confusing. The parameter’s name implies an actual address, where it is meant to store an address ID. Also, which address is it referring to? Yet another meaningless parameter name is `@date`. Is this the order date? The delivery date? It could even imply a timestamp of when the record was inserted into the table! Within the body of the procedure, we also have confusing variable names. The `@stock` variable is meant to hold the quantity ordered and `@product` is holding the product ID. These names simply are not clear, and you need to wade through the code to understand their purpose.

Listing 2.3 `sp_orders` procedure definition

```sql
CREATE PROCEDURE sp_orders
    @CustomerID INT,
    @LineItems XML,
    @AddressID INT,
    @Address INT,
    @date DATETIME
AS
BEGIN
    DECLARE @Stock INT = 0 ;
    DECLARE @Product INT = 0 ;

    INSERT INTO tbl_orders (
        CustomerID,
        LineItems,
        BillingAddressID,
        DeliveryAddressID,
        Date
    )
    VALUES (
        @CustomerID,
        @LineItems,
        @AddressID,
        @Address,
        @date
    ) ;

    SET @Stock = @LineItems.value('(/Product/@qty)[1]', 'int') ;
    SET @Product = @LineItems.value('(/Product/@ProductID)[1]', 'int') ;

    EXEC sp_stockUpdate @product, @stock ;
END
```

> [!TIP]
>
> If you are not familiar with how to use XML in SQL Server, then you are not alone. In fact, failure to use XML appropriately is another common mistake, which we will explore in chapter 3.

By reading the definition of this stored procedure, we can already see that the meaningless names of parameters and variables are storing up trouble for us. If we need to enhance or debug functionality relating to addresses or time, then we are going to have to spend time figuring out what the data means.

For now, though, we need to fix the problem with the stock inventory update, and this stored procedure definition has allowed us to determine that the `sp_stockUpdate` procedure is likely to contain the code that we need to debug. Let’s take a look at the procedure in listing 2.4.

We can see that `sp_stockUpdate` is a simple stored procedure, which updates the stock level in `SalesDB` and then uses a linked server to update the stock level in the inventory system. We can also see that the cause of the bug is inconsistent names, leading the developer to get confused and pass the product ID into the calculation that updates the quantity remaining in stock while trying to filter the product ID on the quantity of goods being ordered, instead of the actual product ID.

Listing 2.4 `sp_stockUpdate` procedure definition

```sql
CREATE PROCEDURE sp_stockUpdate
    @ProductStockLevel INT,               ①
    @StockID INT                          ①
AS
BEGIN
    UPDATE tbl_products
    SET StockQty = StockQty - @productStockLevel
    WHERE ProductID = @StockID ;

    UPDATE [DCSVR01\Inventory].InventoryDB.dbo.productStock
    SET StockQty = StockQty - @productStockLevel
    WHERE ProductID = @StockID ;
END
```

① Parameter names are inconsistent with both the sp_orders procedure and the table’s column names.

Real-world example

This example is quite simple and is for illustrative purposes, but you can imagine that when you are dealing with complex code, these challenges will quickly become a nightmare. The example in this section is loosely based on a real-world example that I came across. A developer had written a very complex process with five layers of stored procedures and multiple entry points from external applications. Across all of the procedures, there were around 2,000 lines of code. After he moved on, a bug was discovered, and upon trying to resolve the problem, we found that the developer had used variable names, parameter names, and column names interchangeably. The bug itself was simple and should have been resolved within a couple of hours, but because of the tangled web of naming, it took three days of effort to resolve the problem. It then took another two weeks to update all the names to be consistent and perform regression testing.

TIP A positive example of good naming in listing 2.4 comes in the form of the table primary key columns. You will notice that the `tbl_products` table has a `ProductID`, the `tbl_orders` table has an `OrderID`, and the `tbl_addresses` table has an `AddressID`. A common mistake is to use `ID` as a stand-alone column name for the primary key columns in all tables, meaning that the primary key column in every table has the same name. I’m sure you can imagine how confusing this could easily become in the context of a complex stored procedure.

As you have seen, not giving due consideration to naming can introduce bugs, cost valuable time when trying to fix problems, and make it harder to enhance functionality. Therefore, spending a little time to keep names consistent and meaningful is a practice that we should all follow.

This might sound easy, and for small database projects, it usually is. But when you have a large project that is built over a long period of time by multiple developers, it can actually become quite tricky. It can become even more tricky if your project is delivered with *Agile* methodology. Unlike a traditional waterfall project, Agile projects use methodologies such as Sprint or Kanban, which break the backlog of work up into small chunks that can deliver incremental functionality at a faster pace.

The Agile approach can work very well and brings many advantages over waterfall projects. When it is delivered badly, however, there can be an assumption that design, architecture, and planning are not required. In database projects, architecture is always critical, as you must consider important design elements, such as the schema of your tables. Failure to do this will likely result in a tangled mess of tables that are not normalized and probably data duplication and performance problems, as well as increased complexity. If you are going to spend time up front looking at table design, then it is a simple and comparatively quick task to also look at other design elements, such as object naming.

A well-managed database project using Agile methodology will either have a number of design sprints at the start of the project or periodic sprints where a section (usually a schema) of the database is designed.

So what should the developer who wrote our MagicChoc stored procedures have done differently? Consider the new definition of the `sp_orders` procedure in listing 2.5. First, the address parameters are now both obviously IDs. More importantly, it is clear which parameter is for the billing address and which is for the delivery address. The `@date` parameter is now clearly an order date. Not only have we changed the parameter, however, but we have also updated the column name in the table, which removes the ambiguity at this level. The `@product` variable has been updated to `@ProductID`, and not only have we updated the `@stock` variable to be `@OrderQty`, but we have also updated the XML definition to match, making the data clearer, right through the stack. Finally, we have updated the execution of the `sp_updateProductStockLevel` procedure to pass the variable in the correct order. This final change will fix the bug.

Listing 2.5 `sp_orders` procedure new definition

```sql
ALTER PROCEDURE sp_orders
    @CustomerID INT,
    @LineItems XML,
    @BillingAddressID INT,
    @DeliveryAddressID INT,
    @OrderDate DATETIME
AS
BEGIN
    DECLARE @OrderQty INT = 0 ;
    DECLARE @ProductID INT = 0 ;

    INSERT INTO tbl_orders (CustomerID, LineItems, BillingAddressID, DeliveryAddressID, OrderDate)
    VALUES (@CustomerID, @LineItems, @BillingAddressID, @DeliveryAddressID,
@OrderDate) ;

    SET @OrderQty = @LineItems.value('(/Product/@OrderQty)[1]', 'int') ;
    SET @ProductID = @LineItems.value('(/Product/@ProductID)[1]', 'int') ;

    EXEC sp_updateProductStockLevel @OrderQty, @ProductID ;
END
```

> [!TIP]
>
> In the voice of my favorite 1980s private investigator: “I know what you’re thinking, and you’re right. Surely, we should have changed the procedure name as well?” However, I have kept it as is for now, as we will be discussing this name further in mistake #2.

Please also consider the new definition of the `sp_stockUpdate` procedure in listing 2.6. You will notice that the name of the stored procedure has been changed to `sp_updateProductStockLevel`, which is a much more meaningful name for the procedure. With this name, we would have had no problem finding it at the start of this example.

Listing 2.6 `sp_updateProductStockLevel` procedure definition

```sql
CREATE PROCEDURE sp_updateProductStockLevel
    @OrderQty INT,                         ①
    @ProductID INT                         ①
AS
BEGIN
    UPDATE tbl_products
    SET StockQty = StockQty - @OrderQty
    WHERE ProductID = @ProductID ;
    UPDATE [DCSVR01\Inventory].InventoryDB.dbo.productStock
    SET StockQty = StockQty - @OrderQty
    WHERE ProductID = @ProductID ;
END
```

① The parameter names now match the variables being passed into them.

After reviewing the preceding two new stored procedure definitions, you will see how meaningful and consistent naming dramatically helps in making the code self-documenting. While we could add code comments in the two procedures, they would add very little benefit. Anybody who can read T-SQL can now read these definitions, and it will be very clear what the procedures are doing and what data is being passed. This doesn’t mean that comments do not have their place, but this is usually to explain conceptual business logic in very long stored procedures or to specify external inputs/outputs, such as an API contract. If your code is self-documenting, comments should not be required to explain low-level code definitions.

## 2.3 #2 Using object prefixes

Some developers love to use object prefixes. Object prefixes are where `tbl_` is added to the start of all table names, `sp_` is added to the start of stored procedure names, `fn_` is added to the start of function names, and `v_` is added to the start of a view.

Imagine you have a database that contains 250 tables. You are looking for the column definition of a table, so you quickly scan down the list of tables in Object Explorer. However, all of the tables have a `tbl_` prefix. This automatically increases the parse time while you scan.

That is because your brain is wired to follow common patterns. For example, you know the alphabet pretty well, right? Great! Try saying it backwards—from Z to A. It’s surprisingly difficult. That’s because your brain is not wired for that pattern. Even if you do train your brain to follow that pattern, it doesn’t mean that everybody else will find it easy.

It’s the same with scanning prefixed objects. Even if you have trained your brain to be able to easily scan a string from the fifth character onward, your fellow developers, business intelligence developers, and administrators may not have, so you will be inadvertently hindering their productivity.

If there was a good reason for doing this—and there are in some languages, such as ARM in Azure—then I would consider the tradeoff. In SQL Server, however, there is no good reason to do it. The reason that is usually citied is, “Because I need a way to easily identify which objects are of which type.”

So let’s use MagicChoc to explore that reason through a couple of different lenses. Specifically, in the `SalesDB`, there is a table called `tbl_Orders` and a stored procedure called `sp_orders`. Additionally, there is a table called `tbl_customers` and a view called `v_customers`. The first lens is pure identification of object type. Let’s use the customer objects to think about this. There are two ways that you may wish to explore those objects: either through SSMS or through code. Figure 2.3 shows the two objects in Object Explorer.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437401/files/OEBPS/Images/CH02_F03_Carter.png)<br>
**Figure 2.3 Viewing objects through Object Explorer**

As you can see, it is quite easy to determine which is the table and which is the view. The table is displayed under the Tables node, and the view is displayed under the Views node.

What about if you wanted to iterate your objects through code? The query in listing 2.7 demonstrates how to pull back the details of both objects via T-SQL. You will notice that the objects are easily distinguishable by virtue of the `type_desc` column in `sys.objects`.

Listing 2.7 Returning the customers objects

```sql
SELECT
       name
     , type_desc
FROM sys.objects
WHERE name LIKE '%customers%' ;
```

The results of this query are

```sql
Name              type_desc
tbl_customers     USER_TABLE
v_customers             VIEW
```

Once again in the voice of that legendary 1980s detective, “I know what you’re thinking, and you’re right. If we dropped the prefix, the `customers` table and view would have an identical name, and that is not allowed.” And that brings me nicely to the second lens.

You will remember that in mistake #1, we discussed having meaningful object names that made your code self-documenting. Let’s think about this from the perspective of the customers objects. There is a table and a view with exactly the same name. Unless they are performing exactly the same function, that can’t be right, unless the view is just returning all the data from a single underlying table. And if the view is just returning the same data as the table, then why does the view exist?

Reasons for views that map exactly to a table

There are two reasons why some people may have views that just return all columns from a single table. The first is a way of locking the tables to avoid people inadvertently changing the table schema. If you create a view `WITH SCHEMABINDING`, then it is not possible to alter the definition of the table without first dropping (or removing) `SCHEMABINDING` from the view. I do not recommend this approach. It is far better and more understandable to simply limit people’s access to make schema modifications using an appropriate security strategy. There is a design principle called *the principle of least surprise*. I subscribe to this theory.

The second reason that you may see a view returning all columns from a single table is because of a stringent policy that all applications must access data via an abstraction layer. I am certainly in favor of the principle behind this, which is to keep the complexity at the SQL Server level and allow application developers to simply pull data from views and stored procedures. When it is taken to this extreme, however, it adds extra objects to no benefit. You just have more objects to maintain.

In the `SalesDB`, the `tbl_customers` table holds details about customers. Therefore, it has a meaningful name. The `v_customers` view, however, is returning both customer data and order data. Therefore, its name is not appropriate. A more appropriate name might be `customerOrders`.

The `tbl_addresses` table does not have any corresponding views, procedures, or functions, so we can simply go ahead and remove the prefix there. The `tbl_products` table does have a corresponding stored procedure, but that procedure currently has an `sp_` prefix, so we can go ahead and rename this table as well. However, we should rename the stored procedure to `sp_addOrder` to make it meaningful.

> [!TIP]
>
> You guessed it, in the words of Magnum PI: “I know what you’re thinking, and you’re right. Shouldn’t we drop the `sp_` prefix from the stored procedures as well?” Yes, we should, but we are going to discuss this further in mistake #3; for now, we will leave them as they are.

The script in the following listing will drop the prefix from the tables and view.

Listing 2.8 Dropping the prefix

```sql
EXEC sp_rename 'tbl_addresses', 'addresses' ;        ①

EXEC sp_rename 'tbl_orders', 'orders' ;              ①

EXEC sp_rename 'tbl_customers', 'customers' ;        ①

DROP VIEW dbo.v_customers ;                          ②
GO

CREATE VIEW dbo.customerOrders                       ②
AS
SELECT
      c.FirstName
    , c.LastName
    , c.email
    , o.LineItems.value('(/Product/@ProductName)[1]', 'int') AS ProductName
    , o.LineItems.value('(/Product/@OrderQty)[1]', 'int') AS OrderQty
    , o.OrderDate
FROM dbo.customers c
INNER JOIN dbo.orders o
    ON c.CustomerID = o.CustomerID ;
GO

DROP PROCEDURE dbo.sp_orders ;                       ③
GO

CREATE PROCEDURE dbo.sp_addOrder                     ③
    @CustomerID INT,
    @LineItems XML,
    @BillingAddressID INT,
    @DeliveryAddressID INT,
    @OrderDate DATETIME
AS
BEGIN
    DECLARE @OrderQty INT = 0 ;
    DECLARE @ProductID INT = 0 ;

    INSERT INTO orders (
        CustomerID,
        LineItems,
        BillingAddressID,
        DeliveryAddressID,
        OrderDate
    )
    VALUES (
        @CustomerID,
        @LineItems,
        @BillingAddressID,
        @DeliveryAddressID,
        @OrderDate
    ) ;

    SET @OrderQty = @LineItems.value('(/Product/@OrderQty)[1]', 'int') ;
    SET @ProductID = @LineItems.value('(/Product/@ProductID)[1]', 'int') ;

    EXEC sp_updateProductStockLevel @OrderQty, @ProductID ;
END
GO

DROP PROCEDURE dbo.sp_updateProductStockLevel ;       ③
GO

CREATE PROCEDURE dbo.sp_updateProductStockLevel       ③
    @OrderQty INT,
    @ProductID INT
AS
BEGIN
    UPDATE products
    SET StockQty = StockQty - @OrderQty
    WHERE ProductID = @ProductID ;

    UPDATE [DCSVR01\Inventory].InventoryDB.dbo.productStock
    SET StockQty = StockQty - @OrderQty
    WHERE ProductID = @ProductID ;
END
```

① sp_rename automatically updates Foreign Key constraints.

② Drops the view and creates it with the new name. This allows us to also change the definition to use the new table names.

③ While sp_rename can be used with stored procedures, we also need to change the definitions to use the new table names.

## 2.4 #3 The dreaded sp_ prefix

In mistake #2 we spent time discussing why prefixes are not a good idea, so why do we have a mistake dedicated to the `sp_` prefix? The best way to explain why the `sp_` prefix deserves a special shout-out is with an example. Therefore, I would like you to consider the definition of the `sp_AddUser` stored procedure in the `SalesDB`, which can be found in the next listing. This procedure simply adds a new user to the application when they register for an account online via the MagicChoc website.

Listing 2.9 `sp_AddUser` procedure definition

```sql
CREATE PROCEDURE sp_addUser
    @UserDetails XML                                                         ①
AS
BEGIN

    OPEN SYMMETRIC KEY MagicChocKey
        DECRYPTION BY CERTIFICATE MagicChocCertificate ;

    INSERT INTO dbo.customers (
          FirstName
        , LastName
        , email
        , UserPassword
    )
    VALUES (
          @UserDetails.value('(/User/FirstName)[1]','nvarchar(128)')         ②
        , @UserDetails.value('(/User/LastName)[1]','nvarchar(128)')          ②
        , @UserDetails.value('(/User/email)[1]','nvarchar(512)')             ②
        , ENCRYPTBYKEY(KEY_GUID('MagicChocKey'), @UserDetails.value('(/User/ ②
    UserPassword)[1]','nvarchar(128)'))                                      ③
    ) ;

    CLOSE SYMMETRIC KEY MagicChocKey ;
END
```

① The details of the new user are passed from the application as an XML fragment.

② The xQuery value() method is used to pull the values out of the XML fragment and insert them into the customers table.

③ The password is encrypted before being inserted into the table.

The application seems to be throwing a strange error. To diagnose the problem, we can simulate the application calling the stored procedure with the script in the following listing.

Listing 2.10 Calling the `sp_AddUser` stored procedure

```sql
DECLARE @UserDetails XML ;                           ①

SET @UserDetails = N'<User>                          ②
    <FirstName>Peter</FirstName>                     ②
    <LastName>Carter</LastName>                      ②
    <email>peter@carter.com</email>                  ②
    <UserPassword>myPaSSw0rd</UserPassword>          ②
</User>' ;

EXEC sp_adduser @UserDetails ;                       ③
```

① Declares a variable of type XML

② Passes an element-centric XML fragment into the @UserDetails variable

③ Passes the XML fragment into the sp_AddUser stored procedure

Using this script to execute the stored procedure causes the following error to be thrown:

```sql
Msg 257, Level 16, State 3, Procedure sp_adduser, Line 0 [Batch Start Line 94]
Implicit conversion from data type xml to nvarchar is not allowed. Use the
CONVERT function to run this query.
```

Well, that’s odd! The error shows as being on line 0 of the stored procedure, which implies an error passing the `@UserDetails` variable. But there is no NVARCHAR-to- XML conversion happening. The variable is of the XML data type and the procedure’s parameter is defined as the XML data type. So what is going on?

Let’s try an experiment. Let’s run the procedure with no parameters, using the statement `EXEC sp_adduser`. The error output is

```sql
Msg 201, Level 16, State 4, Procedure sp_adduser, Line 0 [Batch Start Line
104]
Procedure or function 'sp_adduser' expects parameter '@loginame', which was
not supplied.
```

Now we have a different error, but that’s even more strange. It is complaining that we are not passing the `@loginname` parameter. But our stored procedure doesn’t have a `@loginname` parameter. It’s almost like we are executing the wrong stored procedure.

We need to get to the bottom of this one. To do so, let’s run the query in listing 2.11, which returns results from the `sys.all_objects` catalog view. This object provides a union of user objects and system objects.

Listing 2.11 Pulling details from `sys.all_objects`

```sql
SELECT
      name
    , SCHEMA_NAME(schema_id) AS SchemaName               ①
    , type_desc
    , is_ms_shipped
FROM sys.all_objects
WHERE name = 'sp_adduser' ;
```

① The SCHEMA_NAME() function is a system function, which converts schema IDs into schema names.

The results of this query are

```sql
name          SchemaName     type_desc               is_ms_shipped
sp_adduser    dbo            SQL_STORED_PROCEDURE    0
sp_adduser    sys            SQL_STORED_PROCEDURE    1
```

The results show that there are two procedures with the same name. The first result is our stored procedure. We can tell this because it is in the `dbo` schema and the `is_ms_shipped` flag is false. The second result is a system-stored procedure with the same name. We can tell it is a system-stored procedure because it is in the `sys` schema and the `is_ms_shipped` flag is true.

> [!TIP]
>
> The `is_ms_shipped` flag highlights objects that are created internally, by SQL Server.

System-stored procedures are stored in a “hidden” read-only database called `resource`, which stores all system objects. These objects appear to be in all databases, however. This means that they can be accessed easily from all databases. All system-stored procedures have an `sp_` prefix, and this prefix should be reserved exclusively for system-stored procedures.

When you execute a stored procedure with an `sp_` prefix, SQL Server will first look for that procedure in the `master` database. Only if it does not find a procedure there will it attempt to find the procedure in the local database where the procedure was executed.

This can be demonstrated using the script in listing 2.12. This script creates a procedure called `sp_listing_2_12` in the `master` database and then executes it from the `SalesDB` database, using a one-part name.

Listing 2.12 Accessing a procedure in `master` from a user database

```sql
USE master                                   ①
GO

CREATE PROCEDURE sp_listing_2_12
AS
BEGIN
    SELECT 'Hello! I am in the master database!' ;
END
GO

USE SalesDb                                   ②
GO

EXEC sp_listing_2_12 ;
```

① Changes the context to master, before creating the procedure

② Changes the context to SalesDB, before executing the procedure

Now that we understand why using the `sp_` prefix is a bad idea, let’s clean up our procedure names. We can achieve this with the script in listing 2.13. Because we do not need to update any procedure definitions, we can use the `sp_rename` procedure to perform this task.

Listing 2.13 Cleaning up procedure names

```sql
EXEC sp_rename 'sp_addOrder', 'addOrder' ;

EXEC sp_rename 'sp_addUser', 'addUser' ;

EXEC sp_rename 'sp_updateProductStockLevel', 'updateProductStockLevel' ;

EXEC sp_rename 'sp_products', 'addProduct' ;                          ①

EXEC sp_rename 'sp_updateStock', 'updateStockLevelAfterManufacture' ; ①
```

① As well as removing the prefix, we have also made the object names more meaningful.

Now that we have resolved all of the mistakes in our object names, it is worth taking a look at what this has done to our component diagram. The updated diagram is shown in figure 2.4.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437401/files/OEBPS/Images/CH02_F04_Carter.png)<br>
**Figure 2.4 Updated component diagram**

## 2.5 #4 Not making time for coding standards

Imagine you are on a team of 10 developers working on a large data-tier application. You are all experienced developers, and you have a tight deadline to hit. It’s tempting to wade straight into writing code. After all, you have all been around the block a few times. You all know to indent your code with four spaces, right? Hold on! Is it four spaces or a tab?

The quickest way to start an argument between two developers is to talk about coding standards. Everybody has their own standards to which they adhere, and everybody thinks that their standards are the best. If we have a single standard, then not everybody will agree with it, but even if it’s imperfect, the consistency means that it is better than having no standard at all.

Depending on the size and complexity of a given project, the coding standards will likely vary in their level of comprehensiveness. They will, however, cover both stylistic choices and technical considerations.

Unlike technical standards, a simple fact about stylistic standards is that it doesn’t really matter what the standards are, provided that you have them and they are implemented consistently across the project.

Coding standards are where architecture comes into play. In mistake #1, we talked about the need for architecture in SQL Server projects to ensure that database schemas are optimally designed and performant. We also mentioned that this architecture should consider naming conventions. Another facet of architecture is ensuring that there is a set of coding standards to which people can adhere.

Stylistic choices may include elements such as

* Indent code with four spaces or tab?
* Should all statements be terminated with a semicolon?
* When listing column names, should the comma separator be at the end of the line or the beginning of the next line?
* Should `ON` clauses be specified on the same line as the `JOIN` clause?
* Should SQL Server keywords be all uppercase?
* Camel case versus Pascal?

Technical standards will likely include the following:

* Do not use cursors.
* Use `UNION ALL` rather than `UNION`, where possible.
* Do not use `*` in the `SELECT` list.
* Do not use `NOLOCK`.
* Avoid using `DISTINCT`.

NOTE These lists are designed to give you an idea of the considerations that go into coding standards. They are not in any way meant to be comprehensive.

So what happens if you do not have coding standards? The simple answer is that developers just do their own thing. To think about the consequences of this, we should consider stylistic choices and technical considerations separately.

For stylistic choices, the problem comes with code maintenance. In the following script (which we saw earlier in this chapter but is repeated here for convenience), we saw an extreme example of what can happen when no stylistic coding standards are in place:

```sql
ALTER PROCEDURE [dbo].[proc01]
AS
BEGIN
;with t3 as (select col1, col2, col3 from tbl03) select t1.col1, t2.col2,
t1.col2, t1.col3, t3.col1, t3.col2 from dbo.tbl01 t1 inner join tbl02 t2 on
t1.col1 = t2.col1 and t1.col3 < 55 inner join t3 on t3.col1 = t1.col1 union
select col1, col2, col3, NULL, NULL, '0' from dbo.tbl04 ;
END
```

While any code is unlikely to be written quite this badly in the real world, remember our conversation in mistake #2 about how our brains get used to certain patterns when parsing lists of objects. The same applies when our brains try to parse code.

Consider the queries in listing 2.14. Imagine that you have just parsed 50 queries in the style of query 1. You then reach a query that is written in the style of query 2. Depending on the complexity of the query, this is going to slow you down—maybe for a few seconds, maybe for a few minutes. The two queries return the same results. They are just written using different standards.

Listing 2.14 Changing code style

```sql
SELECT                                                           ①
      c.FirstName                                                ①
    , c.LastName                                                 ①
    , o.LineItems                                                ①
FROM dbo.customers c                                             ①
LEFT JOIN dbo.orders o                                           ①
    ON c.CustomerID = o.CustomerID                               ①
WHERE c.CustomerID >= 2 AND c.CustomerID <= 3                    ①
    AND c.CustomerID <> 2 ;                                      ①

SELECT                                                           ②
    cust.FirstName,                                              ②
    cust.LastName,                                               ②
    ord.LineItems                                                ②
FROM dbo.customers cust                                          ②
LEFT JOIN (                                                      ②
    SELECT CustomerID,                                           ②
    LineItems                                                    ②
    FROM dbo.Orders                                              ②
) ord ON cust.CustomerID = ord.CustomerID                        ②
WHERE cust.CustomerID BETWEEN 2 AND 3 AND cust.CustomerID != 2 ; ②
```

① Query 1

② Query 2

Ultimately, not using a consistent coding style will slow down the resolution of bugs and the development of new enhancements as your data-tier application moves through its lifecycle.

When we think about the technical coding standards, these are much more prescriptive. If developers do not follow the technical standards, then your application will likely experience degraded performance or even return unexpected results. All of the technical standards listed previously are common mistakes in SQL Server and will be discussed in chapter 5.

## 2.6 #5 Using ordinal column position

SQL Server supports the use of ordinal column numbers in the `ORDER BY` clause. This means that, instead of ordering by a column name, you can order by its ordinal position within the `SELECT` clause. For example, consider the query in the following listing.

Listing 2.15 Ordering by ordinal column position

```sql
SELECT *
FROM SYS.databases
ORDER BY 54 ;                                                    ①
```

① Orders by the 54th column in the SELECT list

So what column have we ordered the query by? The answer is the `log_reuse_wait_desc` column, but the only way of determining that would be to either count the columns in the result set until you get to the 54th column or run the query in listing 2.16, which pulls the column name from the metadata held in catalog views.

Listing 2.16 Pulling the column name from metadata

```sql
SELECT
    c.name
FROM SYS.all_columns c
INNER JOIN SYS.all_objects o
    ON o.object_id = c.object_id
WHERE o.name = 'databases'
    AND c.column_id = 54 ;
```

> [!TIP]
>
> If the object being queried was a user object instead of a system object, then the query would also work if we joined `sys.objects` to `sys.columns`.

Another good reason to avoid the use of ordinal column positions is that they are not stable when the underlying tables are modified. If the second column was deleted from a table, for example, then we would need to update all queries that referred to an ordinal column of 3..*n*, as the ordinal positions would have changed.

## Summary

* Always use object names that are meaningful, with a view to making your code self-documenting.
* Always consider database architecture, which is the design of your database, even within agile projects.
* Avoid using prefixes for database objects, as they can actually make objects harder to locate.
* Be especially careful to avoid using the `sp_` prefix for stored procedures as this indicates that they are a system stored procedure, instead of a user-defined procedure.
* Always make time to ensure that your data-tier application has coding standards. These should form part of your architectural efforts and should consider both stylistic choices as well as technical standards.
* Avoid ordering by ordinal column numbers—unless you enjoy troubleshooting!
